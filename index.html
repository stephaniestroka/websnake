<!DOCTYPE html>
<html>
<head>
<title>Snake</title>
</head>
<body>

<div>
	<h1>Snake Game</h1>
</div>
<div>
	<div style="margin: 24px 0;">
		<button id="start-button" type="button" id="Start">Start</button>
	</div>

	<canvas id="board" width="500", height="500" style="border: 1px solid black;">
	</canvas>

</div>

<script>

const BOARD_WIDTH = 10;
const BOARD_HEIGHT = 10;

let canvas = document.getElementById("board");

const SQUARE_WIDTH = canvas.width / BOARD_WIDTH;
const SQUARE_HEIGHT = canvas.height / BOARD_HEIGHT;

function drawBackground(ctx) {
	/* draw background */
	ctx.beginPath();
	ctx.fillStyle = "lightgrey";
	ctx.rect(0, 0, canvas.width, canvas.width);
	ctx.fill();

	let i, j = 0;
	for (i = 0; i < BOARD_WIDTH; i++) {
		for (j = 0; j < BOARD_HEIGHT; j++) {
			ctx.beginPath();
			ctx.strokeStyle = "black";
			ctx.rect((i * SQUARE_WIDTH), (j * SQUARE_HEIGHT), SQUARE_WIDTH, SQUARE_HEIGHT);
			ctx.stroke();
		}
	}
}

const DIRECTIONS = {
	UP: "up",
	DOWN: "down",
	RIGHT: "right",
	LEFT: "left",
}

class Point {
	constructor(x, y) {
		this.x = x;
		this.y = y;
	}
}

function getNextPos(position, direction) {
	switch (direction) {
		case DIRECTIONS.UP:
			return new Point(position.x, position.y - 1);
		case DIRECTIONS.DOWN:
			return new Point(position.x, position.y + 1);
		case DIRECTIONS.LEFT:
			return new Point(position.x - 1, position.y);
		case DIRECTIONS.RIGHT:
			return new Point(position.x + 1, position.y);
	}
}

function isHorizontal(direction) {
		return direction == DIRECTIONS.RIGHT || direction == DIRECTIONS.LEFT;
}

function isVertical(direction) {
	return !isHorizontal(direction);
}

function getOpposite(direction) {
	switch (direction) {
		case DIRECTIONS.UP:
			return DIRECTIONS.DOWN;
		case DIRECTIONS.DOWN:
			return DIRECTIONS.UP;
		case DIRECTIONS.LEFT:
			return DIRECTIONS.RIGHT;
		case DIRECTIONS.RIGHT:
			return DIRECTIONS.LEFT;
	}
}

class SnakePart {
	// if previous == null, we are at the head
	constructor(previous, position) {
		this.previous = previous;
		this.position = position;
	}
	
	// Moves forward and returns the previous snake part.
	// Does not move if there is no previous snake part (= head).
	move() {
		if (this.previous != null) {
			this.position = this.previous.position;
		}
		return this.previous;
	}

	draw(ctx) {
		let square_x = mod(this.position.x, BOARD_WIDTH); 
		let square_y = mod(this.position.y, BOARD_WIDTH); 

		ctx.beginPath();
		ctx.fillStyle = "black";
		ctx.rect((square_x * SQUARE_WIDTH), (square_y * SQUARE_HEIGHT), SQUARE_WIDTH, SQUARE_HEIGHT);
		ctx.fill();
		return this.previous;
	}

	debug() {
		let square_x = mod(this.position.x, BOARD_WIDTH); 
		let square_y = mod(this.position.y, BOARD_WIDTH); 

		return `(${square_x}, ${square_y})`;
	}
}

function mod(n, m) {
	return ((n % m) + m) % m;
}

class Snake {
	constructor(length, start_pos, direction) {
		this.length = length;
		this.direction = direction;
		let snake_parts = this.createSnakeParts(length, start_pos, direction);
		this.head = snake_parts.head;
		this.tail = snake_parts.tail;
	}

	createSnakeParts(length, start_pos, direction) {
		let head = new SnakePart(null, start_pos);
		console.log("Snake head created: " + head.previous);
		let previous = head;
		let i = 1;
		for (i = 1; i < length; i++) {
			previous = new SnakePart(previous, getNextPos(previous.position, getOpposite(direction)));
		}
		let tail = previous;
		console.log("Snake tail created: " + length);
		return {head, tail};
	}

	changeDirection(direction) {
		if (isHorizontal(direction) && isHorizontal(this.direction)) {
			return;
		}
		if (isVertical(direction) && isVertical(this.direction)) {
			return;
		}
		this.direction = direction;
	}

	move() {
		let previous = this.tail.move();
		while (previous != null) {
			previous = previous.move();
		}
		this.head.position = getNextPos(this.head.position, this.direction);
	}

	draw(ctx) {
		let previous = this.tail.draw(ctx);
		while (previous != null) {
			previous = previous.draw(ctx);
		}
	}

	debug() {
		let previous = this.tail.previous;
		let dbg_str = this.tail.debug();
		while (previous != null) {
			dbg_str = dbg_str + " " + previous.debug();
			previous = previous.previous;
		}
		return dbg_str;
	}
}

let controller = 0;
let ctx = canvas.getContext("2d");

drawBackground(ctx);
let snake = new Snake(3, new Point(2, 4), DIRECTIONS.RIGHT);
console.log(`Snake created: ${snake.debug()}`);

let start_button = document.getElementById("start-button");
start_button.addEventListener("click", function() {
	if (controller != 0) {
		start_button.innerHTML = "Start";
		clearInterval(controller);
		controller = 0;
	} else {
		start_button.innerHTML = "Stop";
		controller = setInterval(function() {
				drawBackground(ctx);
				snake.draw(ctx);
				snake.move();
				// console.log(`Snake updated: ${snake.debug()}`);
				}, 500);
	}

});


function logKey(e) {
	console.log(`${e.code} ${e.keyCode}`);
}

function reactToKeyEvent(event) {
	switch (event.code) {
		case "ArrowRight":
			console.log("Move right");
			snake.changeDirection(DIRECTIONS.RIGHT);
			event.preventDefault();
			break;
		case "ArrowLeft":
			console.log("Move left");
			snake.changeDirection(DIRECTIONS.LEFT);
			event.preventDefault();
			break;
		case "ArrowUp":
			console.log("Move up");
			snake.changeDirection(DIRECTIONS.UP);
			event.preventDefault();
			break;
		case "ArrowDown":
			console.log("Move down");
			snake.changeDirection(DIRECTIONS.DOWN);
			event.preventDefault();
			break;
		default:
			console.log("Key unknown");
	}
}

document.addEventListener('keydown', reactToKeyEvent);

</script>

</body>
</html>
